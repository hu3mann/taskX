# AGENTS.md — Evergreen Agent Entry Point (Dopemux-Compatible)

Evergreen: DO NOT edit per task. Task packets change; this file stays stable.

## 0) Prime rule
TASK PACKETS ARE LAW.
- Implement exactly what the active task packet requests.
- If a coding request arrives without a task packet: STOP and ask for it.

## 1) Dopemux operating mode
Use:
- PLAN mode for architecture/design/planning.
- ACT mode for implementation/refactors/tests/fixes.
Adapt verbosity to attention state: scattered / focused / hyperfocus. (See CLAUDE.md.)

## 2) Dopemux MCP workflow matrix (binding behavior)
Use the right tool for the phase:
- RESEARCH: pal apilookup FIRST for authoritative library/API docs (Context7 is retired).
- DESIGN: pal planner / pal consensus as needed; log decisions to ConPort.
- PLANNING: task-orchestrator FIRST for breakdown.
- IMPLEMENTATION: serena-v2 + dope-context FIRST for codebase context; apilookup for API certainty.
- REVIEW: pal codereviewer before commit; pal secaudit for security-sensitive changes.
- COMMIT: pre-commit run --all-files before committing; update ConPort progress.

(These defaults match the Dopemux workflow matrix and implicit rules.) 

## 3) ConPort logging is mandatory
- Any meaningful decision → ConPort log_decision (what/why/tradeoffs).
- Any progress update → ConPort log_progress / update_progress (status + next).

## 4) Coding conventions (repo-generic defaults)
Follow existing repo style first. If ambiguous:
- Python: type hints for new/changed public functions.
- Prefer small, testable functions; minimize side-effects.
- Errors: never swallow exceptions; fail with actionable messages.
- Logging: do not leak sensitive content.
- I/O: prefer atomic writes (temp → rename).
- Security: never commit secrets; redact before external calls.

## 5) Standard response format (mandatory, every response)
A) MODE: PLAN or ACT + attention state guess (scattered/focused/hyperfocus)
B) PLAN: 3–7 bullets
C) CHANGES: files touched (or “no changes”)
D) COMMANDS RUN + RESULTS (or “not run” + why)
E) CONPORT: what was logged / what must be logged
F) NEXT: one clear next action OR “CHECKPOINT STOP”

## 6) Hard stop conditions
Stop and ask if:
- Task packet is missing, ambiguous, or lacks an allowlist for edits.
- You’d need to invent requirements, data, or “best guesses.”
- Verification gates can’t be run or would be bypassed.
- Instructions conflict (task packet vs repo constraints): STOP and surface the conflict.

<!-- TASKX:AUTOGEN:START -->
## TaskX Command Surface (Autogenerated)

### Command Tree
- taskx bundle
  - taskx bundle export
  - taskx bundle ingest
- taskx case
  - taskx case audit
- taskx ci-gate
- taskx collect-evidence
- taskx commit-run
- taskx commit-sequence
- taskx compile-tasks
- taskx docs
  - taskx docs refresh-llm
- taskx doctor
- taskx dopemux
  - taskx dopemux collect
  - taskx dopemux compile
  - taskx dopemux feedback
  - taskx dopemux gate
  - taskx dopemux loop
  - taskx dopemux promote
  - taskx dopemux run
- taskx finish
- taskx gate-allowlist
- taskx loop
- taskx manifest
  - taskx manifest check
  - taskx manifest finalize
  - taskx manifest init
- taskx orchestrate
- taskx pr
  - taskx pr open
- taskx project
  - taskx project disable
  - taskx project doctor
  - taskx project enable
  - taskx project init
  - taskx project mode
    - taskx project mode set
  - taskx project shell
    - taskx project shell init
    - taskx project shell status
  - taskx project status
  - taskx project upgrade
- taskx promote-run
- taskx route
  - taskx route explain
  - taskx route handoff
  - taskx route init
  - taskx route plan
- taskx run-task
- taskx spec-feedback
- taskx wt
  - taskx wt start

### Assisted Routing (taskx route)
- Config: `.taskx/runtime/availability.yaml`
- Artifacts:
  - `out/taskx_route/ROUTE_PLAN.json`
  - `out/taskx_route/ROUTE_PLAN.md`
  - `out/taskx_route/HANDOFF.md`
- Execution: assisted-only (prints handoffs; does not invoke external runners)

### Availability Summary (deterministic)
- Available runners: claude_code, codex_desktop, copilot_cli
- Available models: gpt-5.1-mini, gpt-5.2, gpt-5.3-codex, haiku-4.5, sonnet-4.55
- Policy:
  - max_cost_tier: high
  - min_total_score: 50
  - stop_on_ambiguity: True
  - escalation_ladder: [gpt-5.1-mini, haiku-4.5, sonnet-4.55, gpt-5.3-codex]

### Minimal schema (snippet, stable)
```yaml
models:
  gpt-5.1-mini:
    strengths: [cheap]
    cost_tier: cheap
    context: medium
runners:
  claude_code:
    available: true
    strengths: [code_edit]
policy:
  max_cost_tier: high
  min_total_score: 50
  stop_on_ambiguity: True
  escalation_ladder: [gpt-5.1-mini, haiku-4.5, sonnet-4.55, gpt-5.3-codex]
```

Generated by: taskx docs refresh-llm
<!-- TASKX:AUTOGEN:END -->

<!-- TASKX:BEGIN -->
<!-- directive-pack:taskx@v1 -->
## TaskX Directives (Base)

1. Task packets are law.
2. Perform only actions explicitly authorized by the active task packet.
3. Scope is strict: no drive-by refactors, no opportunistic cleanup, no hidden extra work.
4. Treat allowlists, file scopes, and verification gates as hard requirements.
5. Use evidence-first reasoning for every claim.
6. Never fabricate command runs, outputs, file states, tests, or approvals.
7. If evidence is missing, mark the claim `UNKNOWN` and define a deterministic check.
8. Verification is mandatory for completion.
9. Record verification with the exact commands run and raw outputs.
10. Do not summarize away failing output; include failure details and exit codes.
11. Deterministic operation is required:
12. Do not claim a command was run unless its output is present in logs.
13. Do not claim a file changed unless the diff reflects it.
14. Use minimal diffs and localized edits.
15. Keep behavior stable unless the packet explicitly authorizes a behavior change.
16. Keep assumptions explicit and testable.
17. Do not invent requirements, contracts, schemas, or policy text.
18. Respect stop conditions exactly as written in the packet.
19. Escalate immediately when blocked by missing artifacts, permissions, or contradictory instructions.
20. Escalation must include:
21. What is blocked.
22. Why it is blocked.
23. The smallest packet change needed to proceed.
24. Completion requires an Implementer Report with:
25. Summary of changes.
26. Files changed and added.
27. Verification commands and raw outputs.
28. Deviations from packet instructions (if any).
29. Explicit stop-condition confirmation.
30. If any required gate was not run, report incomplete and stop.
<!-- TASKX:END -->

<!-- CHATX:BEGIN -->
(disabled)
<!-- CHATX:END -->
