# CODEX.md — Execution Contract (Dopemux-Compatible)

Evergreen: DO NOT edit per task. Task packets change; this file stays stable.

## 0) Prime directive
TASK PACKETS ARE LAW.
Implement exactly what the active task packet requests. No scope expansion.
If no task packet: STOP and ask for it.

## 1) Preflight (every task, mandatory)
1) Determine MODE: PLAN or ACT.
2) Docs-first: pal apilookup for any library/API uncertainty (Context7 is retired).
3) Context-first: serena-v2 + dope-context before editing code.
4) Planning-first (if needed): task-orchestrator breakdown.
5) Decision logging: ConPort log_decision for meaningful choices.

## 2) Review + commit gates (mandatory)
- Before commit: pal codereviewer.
- If security-sensitive: pal secaudit before commit.
- Before commit: pre-commit run --all-files.

## 3) Verification discipline
- Run the task packet’s VERIFICATION commands exactly.
- If none are provided: propose the smallest reasonable repo-native set and run what you can.
- Never claim success without results.

## 4) Output adaptation (attention state)
- scattered → one clear next action, minimal output
- focused → structured, max 3 actions
- hyperfocus → comprehensive plan and deeper checks
(Default: focused)

## 5) Completion response format (mandatory)
A) MODE + attention state
B) PLAN
C) CHANGES (files)
D) COMMANDS RUN + RESULTS
E) CONPORT LOGGING (logged / should log)
F) NEXT ACTION or CHECKPOINT STOP

## 6) New Command Surfaces
- `taskx project shell init|status`
- `taskx project upgrade`
- `taskx route init|plan|handoff|explain`
- `taskx pr open`

Branch restore contract:
- If a TaskX command switches branches, it must restore original branch/HEAD unless explicitly disabled.

<!-- TASKX:AUTOGEN:START -->
## TaskX Command Surface (Autogenerated)

### Command Tree
- taskx bundle
  - taskx bundle export
  - taskx bundle ingest
- taskx case
  - taskx case audit
- taskx ci-gate
- taskx collect-evidence
- taskx commit-run
- taskx commit-sequence
- taskx compile-tasks
- taskx docs
  - taskx docs refresh-llm
- taskx doctor
- taskx dopemux
  - taskx dopemux collect
  - taskx dopemux compile
  - taskx dopemux feedback
  - taskx dopemux gate
  - taskx dopemux loop
  - taskx dopemux promote
  - taskx dopemux run
- taskx finish
- taskx gate-allowlist
- taskx loop
- taskx manifest
  - taskx manifest check
  - taskx manifest finalize
  - taskx manifest init
- taskx orchestrate
- taskx pr
  - taskx pr open
- taskx project
  - taskx project disable
  - taskx project doctor
  - taskx project enable
  - taskx project init
  - taskx project mode
    - taskx project mode set
  - taskx project shell
    - taskx project shell init
    - taskx project shell status
  - taskx project status
  - taskx project upgrade
- taskx promote-run
- taskx route
  - taskx route explain
  - taskx route handoff
  - taskx route init
  - taskx route plan
- taskx run-task
- taskx spec-feedback
- taskx wt
  - taskx wt start

### Assisted Routing (taskx route)
- Config: `.taskx/runtime/availability.yaml`
- Artifacts:
  - `out/taskx_route/ROUTE_PLAN.json`
  - `out/taskx_route/ROUTE_PLAN.md`
  - `out/taskx_route/HANDOFF.md`
- Execution: assisted-only (prints handoffs; does not invoke external runners)

### Availability Summary (deterministic)
- Available runners: claude_code, codex_desktop, copilot_cli
- Available models: gpt-5.1-mini, gpt-5.2, gpt-5.3-codex, haiku-4.5, sonnet-4.55
- Policy:
  - max_cost_tier: high
  - min_total_score: 50
  - stop_on_ambiguity: True
  - escalation_ladder: [gpt-5.1-mini, haiku-4.5, sonnet-4.55, gpt-5.3-codex]

### Minimal schema (snippet, stable)
```yaml
models:
  gpt-5.1-mini:
    strengths: [cheap]
    cost_tier: cheap
    context: medium
runners:
  claude_code:
    available: true
    strengths: [code_edit]
policy:
  max_cost_tier: high
  min_total_score: 50
  stop_on_ambiguity: True
  escalation_ladder: [gpt-5.1-mini, haiku-4.5, sonnet-4.55, gpt-5.3-codex]
```

Generated by: taskx docs refresh-llm
<!-- TASKX:AUTOGEN:END -->

<!-- TASKX:BEGIN -->
<!-- directive-pack:taskx@v1 -->
## TaskX Directives (Base)

1. Task packets are law.
2. Perform only actions explicitly authorized by the active task packet.
3. Scope is strict: no drive-by refactors, no opportunistic cleanup, no hidden extra work.
4. Treat allowlists, file scopes, and verification gates as hard requirements.
5. Use evidence-first reasoning for every claim.
6. Never fabricate command runs, outputs, file states, tests, or approvals.
7. If evidence is missing, mark the claim `UNKNOWN` and define a deterministic check.
8. Verification is mandatory for completion.
9. Record verification with the exact commands run and raw outputs.
10. Do not summarize away failing output; include failure details and exit codes.
11. Deterministic operation is required:
12. Do not claim a command was run unless its output is present in logs.
13. Do not claim a file changed unless the diff reflects it.
14. Use minimal diffs and localized edits.
15. Keep behavior stable unless the packet explicitly authorizes a behavior change.
16. Keep assumptions explicit and testable.
17. Do not invent requirements, contracts, schemas, or policy text.
18. Respect stop conditions exactly as written in the packet.
19. Escalate immediately when blocked by missing artifacts, permissions, or contradictory instructions.
20. Escalation must include:
21. What is blocked.
22. Why it is blocked.
23. The smallest packet change needed to proceed.
24. Completion requires an Implementer Report with:
25. Summary of changes.
26. Files changed and added.
27. Verification commands and raw outputs.
28. Deviations from packet instructions (if any).
29. Explicit stop-condition confirmation.
30. If any required gate was not run, report incomplete and stop.
<!-- TASKX:END -->

<!-- CHATX:BEGIN -->
(disabled)
<!-- CHATX:END -->
